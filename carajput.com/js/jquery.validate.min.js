function recaptchaCallback() {
    $("#hiddenRecaptchaBottom").valid()
}! function(t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery)
}(function(u) {
    u.extend(u.fn, {
        validate: function(t) {
            var s;
            if (this.length) return (s = u.data(this[0], "validator")) || (this.attr("novalidate", "novalidate"), s = new u.validator(t, this[0]), u.data(this[0], "validator", s), s.settings.onsubmit && (this.validateDelegate(":submit", "click", function(t) {
                s.settings.submitHandler && (s.submitButton = t.target), u(t.target).hasClass("cancel") && (s.cancelSubmit = !0), void 0 !== u(t.target).attr("formnovalidate") && (s.cancelSubmit = !0)
            }), this.submit(function(i) {
                function t() {
                    var t, e;
                    return !s.settings.submitHandler || (s.submitButton && (t = u("<input type='hidden'/>").attr("name", s.submitButton.name).val(u(s.submitButton).val()).appendTo(s.currentForm)), e = s.settings.submitHandler.call(s, s.currentForm, i), s.submitButton && t.remove(), void 0 !== e && e)
                }
                return s.settings.debug && i.preventDefault(), s.cancelSubmit ? (s.cancelSubmit = !1, t()) : s.form() ? s.pendingRequest ? !(s.formSubmitted = !0) : t() : (s.focusInvalid(), !1)
            }))), s;
            t && t.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")
        },
        valid: function() {
            var t, e;
            return u(this[0]).is("form") ? t = this.validate().form() : (t = !0, e = u(this[0].form).validate(), this.each(function() {
                t = e.element(this) && t
            })), t
        },
        removeAttrs: function(t) {
            var i = {},
                s = this;
            return u.each(t.split(/\s/), function(t, e) {
                i[e] = s.attr(e), s.removeAttr(e)
            }), i
        },
        rules: function(t, e) {
            var i, s, n, r, a, o = this[0];
            if (t) switch (s = (i = u.data(o.form, "validator").settings).rules, n = u.validator.staticRules(o), t) {
                case "add":
                    u.extend(n, u.validator.normalizeRule(e)), delete n.messages, s[o.name] = n, e.messages && (i.messages[o.name] = u.extend(i.messages[o.name], e.messages));
                    break;
                case "remove":
                    return e ? (a = {}, u.each(e.split(/\s/), function(t, e) {
                        a[e] = n[e], delete n[e], "required" === e && u(o).removeAttr("aria-required")
                    }), a) : (delete s[o.name], n)
            }
            return (t = u.validator.normalizeRules(u.extend({}, u.validator.classRules(o), u.validator.attributeRules(o), u.validator.dataRules(o), u.validator.staticRules(o)), o)).required && (r = t.required, delete t.required, t = u.extend({
                required: r
            }, t), u(o).attr("aria-required", "true")), t.remote && (r = t.remote, delete t.remote, t = u.extend(t, {
                remote: r
            })), t
        }
    }), u.extend(u.expr[":"], {
        blank: function(t) {
            return !u.trim("" + u(t).val())
        },
        filled: function(t) {
            return !!u.trim("" + u(t).val())
        },
        unchecked: function(t) {
            return !u(t).prop("checked")
        }
    }), u.validator = function(t, e) {
        this.settings = u.extend(!0, {}, u.validator.defaults, t), this.currentForm = e, this.init()
    }, u.validator.format = function(i, t) {
        return 1 === arguments.length ? function() {
            var t = u.makeArray(arguments);
            return t.unshift(i), u.validator.format.apply(this, t)
        } : ((t = 2 < arguments.length && t.constructor !== Array ? u.makeArray(arguments).slice(1) : t).constructor !== Array && (t = [t]), u.each(t, function(t, e) {
            i = i.replace(new RegExp("\\{" + t + "\\}", "g"), function() {
                return e
            })
        }), i)
    }, u.extend(u.validator, {
        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            validClass: "valid",
            errorElement: "span",
            focusCleanup: !1,
            focusInvalid: !0,
            errorContainer: u([]),
            errorLabelContainer: u([]),
            onsubmit: !0,
            ignore: ":hidden",
            ignoreTitle: !1,
            onfocusin: function(t) {
                this.lastActive = t, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, t, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(t)))
            },
            onfocusout: function(t) {
                this.checkable(t) || !(t.name in this.submitted) && this.optional(t) || this.element(t)
            },
            onkeyup: function(t, e) {
                9 === e.which && "" === this.elementValue(t) || (t.name in this.submitted || t === this.lastElement) && this.element(t)
            },
            onclick: function(t) {
                t.name in this.submitted ? this.element(t) : t.parentNode.name in this.submitted && this.element(t.parentNode)
            },
            highlight: function(t, e, i) {
                ("radio" === t.type ? this.findByName(t.name) : u(t)).addClass(e).removeClass(i)
            },
            unhighlight: function(t, e, i) {
                ("radio" === t.type ? this.findByName(t.name) : u(t)).removeClass(e).addClass(i)
            }
        },
        setDefaults: function(t) {
            u.extend(u.validator.defaults, t)
        },
        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date ( ISO ).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            creditcard: "Please enter a valid credit card number.",
            equalTo: "Please enter the same value again.",
            maxlength: u.validator.format("Please enter no more than {0} characters."),
            minlength: u.validator.format("Please enter at least {0} characters."),
            rangelength: u.validator.format("Please enter a value between {0} and {1} characters long."),
            range: u.validator.format("Please enter a value between {0} and {1}."),
            max: u.validator.format("Please enter a value less than or equal to {0}."),
            min: u.validator.format("Please enter a value greater than or equal to {0}.")
        },
        autoCreateRanges: !1,
        prototype: {
            init: function() {
                this.labelContainer = u(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || u(this.currentForm), this.containers = u(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();
                var i, s = this.groups = {};

                function t(t) {
                    var e = u.data(this[0].form, "validator"),
                        i = "on" + t.type.replace(/^validate/, ""),
                        s = e.settings;
                    s[i] && !this.is(s.ignore) && s[i].call(e, this[0], t)
                }
                u.each(this.settings.groups, function(i, t) {
                    "string" == typeof t && (t = t.split(/\s/)), u.each(t, function(t, e) {
                        s[e] = i
                    })
                }), i = this.settings.rules, u.each(i, function(t, e) {
                    i[t] = u.validator.normalizeRule(e)
                }), u(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox']", "focusin focusout keyup", t).validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", t), this.settings.invalidHandler && u(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler), u(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true")
            },
            form: function() {
                return this.checkForm(), u.extend(this.submitted, this.errorMap), this.invalid = u.extend({}, this.errorMap), this.valid() || u(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid()
            },
            checkForm: function() {
                this.prepareForm();
                for (var t = 0, e = this.currentElements = this.elements(); e[t]; t++) this.check(e[t]);
                return this.valid()
            },
            element: function(t) {
                var e = this.clean(t),
                    i = this.validationTargetFor(e),
                    s = !0;
                return void 0 === (this.lastElement = i) ? delete this.invalid[e.name] : (this.prepareElement(i), this.currentElements = u(i), (s = !1 !== this.check(i)) ? delete this.invalid[i.name] : this.invalid[i.name] = !0), u(t).attr("aria-invalid", !s), this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), s
            },
            showErrors: function(e) {
                if (e) {
                    for (var t in u.extend(this.errorMap, e), this.errorList = [], e) this.errorList.push({
                        message: e[t],
                        element: this.findByName(t)[0]
                    });
                    this.successList = u.grep(this.successList, function(t) {
                        return !(t.name in e)
                    })
                }
                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
            },
            resetForm: function() {
                u.fn.resetForm && u(this.currentForm).resetForm(), this.submitted = {}, this.lastElement = null, this.prepareForm(), this.hideErrors(), this.elements().removeClass(this.settings.errorClass).removeData("previousValue").removeAttr("aria-invalid")
            },
            numberOfInvalids: function() {
                return this.objectLength(this.invalid)
            },
            objectLength: function(t) {
                var e, i = 0;
                for (e in t) i++;
                return i
            },
            hideErrors: function() {
                this.hideThese(this.toHide)
            },
            hideThese: function(t) {
                t.not(this.containers).text(""), this.addWrapper(t).hide()
            },
            valid: function() {
                return 0 === this.size()
            },
            size: function() {
                return this.errorList.length
            },
            focusInvalid: function() {
                if (this.settings.focusInvalid) try {
                    u(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin")
                } catch (t) {}
            },
            findLastActive: function() {
                var e = this.lastActive;
                return e && 1 === u.grep(this.errorList, function(t) {
                    return t.element.name === e.name
                }).length && e
            },
            elements: function() {
                var t = this,
                    e = {};
                return u(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled], [readonly]").not(this.settings.ignore).filter(function() {
                    return !this.name && t.settings.debug && window.console && console.error("%o has no name assigned", this), !(this.name in e || !t.objectLength(u(this).rules())) && (e[this.name] = !0)
                })
            },
            clean: function(t) {
                return u(t)[0]
            },
            errors: function() {
                var t = this.settings.errorClass.split(" ").join(".");
                return u(this.settings.errorElement + "." + t, this.errorContext)
            },
            reset: function() {
                this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = u([]), this.toHide = u([]), this.currentElements = u([])
            },
            prepareForm: function() {
                this.reset(), this.toHide = this.errors().add(this.containers)
            },
            prepareElement: function(t) {
                this.reset(), this.toHide = this.errorsFor(t)
            },
            elementValue: function(t) {
                var e = u(t),
                    i = t.type;
                return "radio" === i || "checkbox" === i ? u("input[name='" + t.name + "']:checked").val() : "number" === i && void 0 !== t.validity ? !t.validity.badInput && e.val() : "string" == typeof(i = e.val()) ? i.replace(/\r/g, "") : i
            },
            check: function(e) {
                e = this.validationTargetFor(this.clean(e));
                var t, i, s, n = u(e).rules(),
                    r = u.map(n, function(t, e) {
                        return e
                    }).length,
                    a = !1,
                    o = this.elementValue(e);
                for (i in n) {
                    s = {
                        method: i,
                        parameters: n[i]
                    };
                    try {
                        if ("dependency-mismatch" === (t = u.validator.methods[i].call(this, o, e, s.parameters)) && 1 === r) a = !0;
                        else {
                            if (a = !1, "pending" === t) return void(this.toHide = this.toHide.not(this.errorsFor(e)));
                            if (!t) return this.formatAndAdd(e, s), !1
                        }
                    } catch (t) {
                        throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + e.id + ", check the '" + s.method + "' method.", t), t
                    }
                }
                if (!a) return this.objectLength(n) && this.successList.push(e), !0
            },
            customDataMessage: function(t, e) {
                return u(t).data("msg" + e.charAt(0).toUpperCase() + e.substring(1).toLowerCase()) || u(t).data("msg")
            },
            customMessage: function(t, e) {
                t = this.settings.messages[t];
                return t && (t.constructor === String ? t : t[e])
            },
            findDefined: function() {
                for (var t = 0; t < arguments.length; t++)
                    if (void 0 !== arguments[t]) return arguments[t]
            },
            defaultMessage: function(t, e) {
                return this.findDefined(this.customMessage(t.name, e), this.customDataMessage(t, e), !this.settings.ignoreTitle && t.title || void 0, u.validator.messages[e], "<strong>Warning: No message defined for " + t.name + "</strong>")
            },
            formatAndAdd: function(t, e) {
                var i = this.defaultMessage(t, e.method),
                    s = /\$?\{(\d+)\}/g;
                "function" == typeof i ? i = i.call(this, e.parameters, t) : s.test(i) && (i = u.validator.format(i.replace(s, "{$1}"), e.parameters)), this.errorList.push({
                    message: i,
                    element: t,
                    method: e.method
                }), this.errorMap[t.name] = i, this.submitted[t.name] = i
            },
            addWrapper: function(t) {
                return t = this.settings.wrapper ? t.add(t.parent(this.settings.wrapper)) : t
            },
            defaultShowErrors: function() {
                for (var t, e, i = 0; this.errorList[i]; i++) e = this.errorList[i], this.settings.highlight && this.settings.highlight.call(this, e.element, this.settings.errorClass, this.settings.validClass), this.showLabel(e.element, e.message);
                if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success)
                    for (i = 0; this.successList[i]; i++) this.showLabel(this.successList[i]);
                if (this.settings.unhighlight)
                    for (i = 0, t = this.validElements(); t[i]; i++) this.settings.unhighlight.call(this, t[i], this.settings.errorClass, this.settings.validClass);
                this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show()
            },
            validElements: function() {
                return this.currentElements.not(this.invalidElements())
            },
            invalidElements: function() {
                return u(this.errorList).map(function() {
                    return this.element
                })
            },
            showLabel: function(t, e) {
                var i, s, n = this.errorsFor(t),
                    r = this.idOrName(t),
                    a = u(t).attr("aria-describedby");
                n.length ? (n.removeClass(this.settings.validClass).addClass(this.settings.errorClass), n.html(e)) : (s = n = u("<" + this.settings.errorElement + ">").attr("id", r + "-error").addClass(this.settings.errorClass).html(e || ""), this.settings.wrapper && (s = n.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(s) : this.settings.errorPlacement ? this.settings.errorPlacement(s, u(t)) : s.insertAfter(t), n.is("label") ? n.attr("for", r) : 0 === n.parents("label[for='" + r + "']").length && (s = n.attr("id").replace(/(:|\.|\[|\])/g, "\\$1"), a ? a.match(new RegExp("\\b" + s + "\\b")) || (a += " " + s) : a = s, u(t).attr("aria-describedby", a), i = this.groups[t.name]) && u.each(this.groups, function(t, e) {
                    e === i && u("[name='" + t + "']", this.currentForm).attr("aria-describedby", n.attr("id"))
                })), !e && this.settings.success && (n.text(""), "string" == typeof this.settings.success ? n.addClass(this.settings.success) : this.settings.success(n, t)), this.toShow = this.toShow.add(n)
            },
            errorsFor: function(t) {
                var e = this.idOrName(t),
                    t = u(t).attr("aria-describedby"),
                    e = "label[for='" + e + "'], label[for='" + e + "'] *";
                return t && (e = e + ", #" + t.replace(/\s+/g, ", #")), this.errors().filter(e)
            },
            idOrName: function(t) {
                return this.groups[t.name] || !this.checkable(t) && t.id || t.name
            },
            validationTargetFor: function(t) {
                return this.checkable(t) && (t = this.findByName(t.name)), u(t).not(this.settings.ignore)[0]
            },
            checkable: function(t) {
                return /radio|checkbox/i.test(t.type)
            },
            findByName: function(t) {
                return u(this.currentForm).find("[name='" + t + "']")
            },
            getLength: function(t, e) {
                switch (e.nodeName.toLowerCase()) {
                    case "select":
                        return u("option:selected", e).length;
                    case "input":
                        if (this.checkable(e)) return this.findByName(e.name).filter(":checked").length
                }
                return t.length
            },
            depend: function(t, e) {
                return !this.dependTypes[typeof t] || this.dependTypes[typeof t](t, e)
            },
            dependTypes: {
                boolean: function(t) {
                    return t
                },
                string: function(t, e) {
                    return !!u(t, e.form).length
                },
                function: function(t, e) {
                    return t(e)
                }
            },
            optional: function(t) {
                var e = this.elementValue(t);
                return !u.validator.methods.required.call(this, e, t) && "dependency-mismatch"
            },
            startRequest: function(t) {
                this.pending[t.name] || (this.pendingRequest++, this.pending[t.name] = !0)
            },
            stopRequest: function(t, e) {
                this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[t.name], e && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (u(this.currentForm).submit(), this.formSubmitted = !1) : !e && 0 === this.pendingRequest && this.formSubmitted && (u(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1)
            },
            previousValue: function(t) {
                return u.data(t, "previousValue") || u.data(t, "previousValue", {
                    old: null,
                    valid: !0,
                    message: this.defaultMessage(t, "remote")
                })
            }
        },
        classRuleSettings: {
            required: {
                required: !0
            },
            email: {
                email: !0
            },
            url: {
                url: !0
            },
            date: {
                date: !0
            },
            dateISO: {
                dateISO: !0
            },
            number: {
                number: !0
            },
            digits: {
                digits: !0
            },
            creditcard: {
                creditcard: !0
            }
        },
        addClassRules: function(t, e) {
            t.constructor === String ? this.classRuleSettings[t] = e : u.extend(this.classRuleSettings, t)
        },
        classRules: function(t) {
            var e = {},
                t = u(t).attr("class");
            return t && u.each(t.split(" "), function() {
                this in u.validator.classRuleSettings && u.extend(e, u.validator.classRuleSettings[this])
            }), e
        },
        attributeRules: function(t) {
            var e, i, s = {},
                n = u(t),
                r = t.getAttribute("type");
            for (e in u.validator.methods) i = "required" === e ? !!(i = "" === (i = t.getAttribute(e)) ? !0 : i) : n.attr(e), (i = /min|max/.test(e) && (null === r || /number|range|text/.test(r)) ? Number(i) : i) || 0 === i ? s[e] = i : r === e && "range" !== r && (s[e] = !0);
            return s.maxlength && /-1|2147483647|524288/.test(s.maxlength) && delete s.maxlength, s
        },
        dataRules: function(t) {
            var e, i, s = {},
                n = u(t);
            for (e in u.validator.methods) void 0 !== (i = n.data("rule" + e.charAt(0).toUpperCase() + e.substring(1).toLowerCase())) && (s[e] = i);
            return s
        },
        staticRules: function(t) {
            var e = {},
                i = u.data(t.form, "validator");
            return e = i.settings.rules ? u.validator.normalizeRule(i.settings.rules[t.name]) || {} : e
        },
        normalizeRules: function(s, n) {
            return u.each(s, function(t, e) {
                if (!1 === e) delete s[t];
                else if (e.param || e.depends) {
                    var i = !0;
                    switch (typeof e.depends) {
                        case "string":
                            i = !!u(e.depends, n.form).length;
                            break;
                        case "function":
                            i = e.depends.call(n, n)
                    }
                    i ? s[t] = void 0 === e.param || e.param : delete s[t]
                }
            }), u.each(s, function(t, e) {
                s[t] = u.isFunction(e) ? e(n) : e
            }), u.each(["minlength", "maxlength"], function() {
                s[this] && (s[this] = Number(s[this]))
            }), u.each(["rangelength", "range"], function() {
                var t;
                s[this] && (u.isArray(s[this]) ? s[this] = [Number(s[this][0]), Number(s[this][1])] : "string" == typeof s[this] && (t = s[this].replace(/[\[\]]/g, "").split(/[\s,]+/), s[this] = [Number(t[0]), Number(t[1])]))
            }), u.validator.autoCreateRanges && (null != s.min && null != s.max && (s.range = [s.min, s.max], delete s.min, delete s.max), null != s.minlength) && null != s.maxlength && (s.rangelength = [s.minlength, s.maxlength], delete s.minlength, delete s.maxlength), s
        },
        normalizeRule: function(t) {
            var e;
            return "string" == typeof t && (e = {}, u.each(t.split(/\s/), function() {
                e[this] = !0
            }), t = e), t
        },
        addMethod: function(t, e, i) {
            u.validator.methods[t] = e, u.validator.messages[t] = void 0 !== i ? i : u.validator.messages[t], e.length < 3 && u.validator.addClassRules(t, u.validator.normalizeRule(t))
        },
        methods: {
            required: function(t, e, i) {
                return this.depend(i, e) ? "select" === e.nodeName.toLowerCase() ? (i = u(e).val()) && 0 < i.length : this.checkable(e) ? 0 < this.getLength(t, e) : 0 < u.trim(t).length : "dependency-mismatch"
            },
            email: function(t, e) {
                return this.optional(e) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(t)
            },
            url: function(t, e) {
                return this.optional(e) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(t)
            },
            date: function(t, e) {
                return this.optional(e) || !/Invalid|NaN/.test(new Date(t).toString())
            },
            dateISO: function(t, e) {
                return this.optional(e) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(t)
            },
            number: function(t, e) {
                return this.optional(e) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t)
            },
            digits: function(t, e) {
                return this.optional(e) || /^\d+$/.test(t)
            },
            creditcard: function(t, e) {
                if (this.optional(e)) return "dependency-mismatch";
                if (/[^0-9 \-]+/.test(t)) return !1;
                var i, s, n = 0,
                    r = 0,
                    a = !1;
                if ((t = t.replace(/\D/g, "")).length < 13 || 19 < t.length) return !1;
                for (i = t.length - 1; 0 <= i; i--) s = t.charAt(i), r = parseInt(s, 10), a && 9 < (r *= 2) && (r -= 9), n += r, a = !a;
                return n % 10 == 0
            },
            minlength: function(t, e, i) {
                t = u.isArray(t) ? t.length : this.getLength(t, e);
                return this.optional(e) || i <= t
            },
            maxlength: function(t, e, i) {
                t = u.isArray(t) ? t.length : this.getLength(t, e);
                return this.optional(e) || t <= i
            },
            rangelength: function(t, e, i) {
                t = u.isArray(t) ? t.length : this.getLength(t, e);
                return this.optional(e) || t >= i[0] && t <= i[1]
            },
            min: function(t, e, i) {
                return this.optional(e) || i <= t
            },
            max: function(t, e, i) {
                return this.optional(e) || t <= i
            },
            range: function(t, e, i) {
                return this.optional(e) || t >= i[0] && t <= i[1]
            },
            equalTo: function(t, e, i) {
                i = u(i);
                return this.settings.onfocusout && i.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
                    u(e).valid()
                }), t === i.val()
            },
            remote: function(s, n, t) {
                var r, a, e;
                return this.optional(n) ? "dependency-mismatch" : (r = this.previousValue(n), this.settings.messages[n.name] || (this.settings.messages[n.name] = {}), r.originalMessage = this.settings.messages[n.name].remote, this.settings.messages[n.name].remote = r.message, t = "string" == typeof t ? {
                    url: t
                } : t, r.old === s ? r.valid : (r.old = s, (a = this).startRequest(n), (e = {})[n.name] = s, u.ajax(u.extend(!0, {
                    url: t,
                    mode: "abort",
                    port: "validate" + n.name,
                    dataType: "json",
                    data: e,
                    context: a.currentForm,
                    success: function(t) {
                        var e, i = !0 === t || "true" === t;
                        a.settings.messages[n.name].remote = r.originalMessage, i ? (e = a.formSubmitted, a.prepareElement(n), a.formSubmitted = e, a.successList.push(n), delete a.invalid[n.name], a.showErrors()) : (e = {}, t = t || a.defaultMessage(n, "remote"), e[n.name] = r.message = u.isFunction(t) ? t(s) : t, a.invalid[n.name] = !0, a.showErrors(e)), r.valid = i, a.stopRequest(n, i)
                    }
                }, t)), "pending"))
            }
        }
    }), u.format = function() {
        throw "$.format has been deprecated. Please use $.validator.format instead."
    };
    var s, n = {};
    u.ajaxPrefilter ? u.ajaxPrefilter(function(t, e, i) {
        var s = t.port;
        "abort" === t.mode && (n[s] && n[s].abort(), n[s] = i)
    }) : (s = u.ajax, u.ajax = function(t) {
        var e = ("mode" in t ? t : u.ajaxSettings).mode,
            i = ("port" in t ? t : u.ajaxSettings).port;
        return "abort" === e ? (n[i] && n[i].abort(), n[i] = s.apply(this, arguments), n[i]) : s.apply(this, arguments)
    }), u.extend(u.fn, {
        validateDelegate: function(i, t, s) {
            return this.bind(t, function(t) {
                var e = u(t.target);
                if (e.is(i)) return s.apply(e, arguments)
            })
        }
    })
});